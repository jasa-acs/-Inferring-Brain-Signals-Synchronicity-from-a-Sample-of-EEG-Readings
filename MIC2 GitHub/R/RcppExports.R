# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' MIC sampling function in C++
#'
#' \code{MIC_mcmc} performs Gibbs sampling in C++ as an essential part of
#'   \code{\link{MIC}}
#'
#' @param data, R list of 3D array, see \code{\link{MIC}}
#' @param K,    integer as number of clusters
#' @param run,  integer as number of MCMC samples
#' @param thin, integer as thinning every few iterations
#'
MIC_mcmc <- function(data, K, run, thin) {
    .Call('_MIC2_MIC_mcmc', PACKAGE = 'MIC2', data, K, run, thin)
}

#' Cpp function for Parzen window smoothed power spectral density
#'
#' \code{specParzen} uses a parzen window smoothed autocovariance function
#'   to estimate the correlogram with trunction. Please refer to the R function
#'   \code{\link{spec.parzen}} for general usage.
#'
#' @param ts,    vector of the time series
#' @param lag,   integer of the max lag to truncate acf
#' @param maxf,  integer of the max frequency to consider
#' @param outn,  integer of the length of the spectral estimates
#' @return vector of estimated spectral density of length \code{outn}
#'
specParzen <- function(ts, lag, maxf, outn) {
    .Call('_MIC2_specParzen', PACKAGE = 'MIC2', ts, lag, maxf, outn)
}

#' Spectral similarity based on Total Variation Distance (TVD)
#'
#' \code{SpecSim} calculates the similarity between two normalized PSD, defined as
#'     their common area under the curves. It also correspond to \code{1-TVD(f,g)}
#'     for two normalized densities \code{f} and \code{g}. For its usage, please
#'     refer to \code{\link{MIC_prep}}.
#'
#' @param ts,   3 dimensional array of time series
#' @param lag,  integer, trunctation for spectral estimates in \code{\link{spec.parzen}}
#' @param wn,   integer, maximal frequency as in \code{\link{specParzen}}
#' @param win,  integer, moving average window size for spectral smoothing
#' @param overlap, integer, moving average overlap size for spectral smoothing
#' @param specN, integer, spectral resolution in \code{\link{specParzen}}
#' @return 3d array admissible to \code{\link{EigLap}}
#'
#' @seealso \code{\link{spec.parzen}} for spectral density estimates and \code{\link{MIC_prep}}
#'   for time series preprocessing before \code{\link{MIC}}
SpecSim <- function(ts, lag, wn, win, overlap, specN) {
    .Call('_MIC2_SpecSim', PACKAGE = 'MIC2', ts, lag, wn, win, overlap, specN)
}

#' Eigen Laplacian transformation
#'
#' \code{EigLap} operates on symmatrical similarity matrices seeking a \code{D}
#'   dimensional representation using its first \code{D} eigen-vectors of its
#'   graph Laplacians.
#'
#' @param data,  3 dimensional array of similarity matrices
#' @param D,     integer of the dimensionality transforming into
#' @param normal, logical of whether to perform normalization on transformed data.
#' @return 3d array admissible to \code{\link{MIC}}
#'
#' @references Andew Ng, Michael Jordan and Yair Weiss "\emph{On Spectral Clustering:
#'   Analysis and an Algorithm}"
#'
#' @seealso \code{\link{MIC_prep}} for its usage.
#'
EigLap <- function(data, D, normal) {
    .Call('_MIC2_EigLap', PACKAGE = 'MIC2', data, D, normal)
}

#' Spectral densities averaged by overlapped sliding windows
#'
#' \code{SpecOnly} calculates the normalized PSD averaged within sliding windows.
#'     For its usage, please refer to \code{\link{MIC_prep}}.
#'
#' @param ts,   3 dimensional array of time series
#' @param lag,  integer, trunctation for spectral estimates in \code{\link{spec.parzen}}
#' @param wn,   integer, maximal frequency as in \code{\link{specParzen}}
#' @param win,  integer, moving average window size for spectral smoothing
#' @param overlap, integer, moving average overlap size for spectral smoothing
#' @param specN, integer, spectral resolution in \code{\link{specParzen}}
#' @return 3d array of spectral densities
#'
#' @seealso \code{\link{spec.parzen}} for spectral density estimates and \code{\link{MIC_prep}}
#'   for time series preprocessing before \code{\link{MIC}}
SpecOnly <- function(ts, lag, wn, win, overlap, specN) {
    .Call('_MIC2_SpecOnly', PACKAGE = 'MIC2', ts, lag, wn, win, overlap, specN)
}

#' Cpp function for aligning indicator matrices
#'
#' \code{clustalign} performs indicator matrices alignment to achieve maximal
#'   concordance of \code{now} to the reference \code{ref}, by swapping the rows
#'   of matrix \code{now}. Please refer to \code{\link{align}} for general vector
#'   and matrix alignment.
#'
#' @param now,  matrix with its rows to be realigned
#' @param ref,  matrix to be used as reference
#' @return no value returned, and matrix \code{now} is aligned on the spot
#'
clustalign <- function(now, ref) {
    invisible(.Call('_MIC2_clustalign', PACKAGE = 'MIC2', now, ref))
}

